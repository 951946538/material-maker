{"name":"bricks","node_position":{"x":0,"y":0},"parameters":{"bevel":0.1,"columns":3,"mortar":0.1,"pattern":0,"repeat":1,"row_offset":0.5,"rows":6},"shader_model":{"global":"\n\t\tvec3 brick(vec2 uv, vec2 bmin, vec2 bmax, float mortar, float bevel) {\n\t\t\tfloat color = 0.5;\n\t\t\tvec2 c1 = (uv-bmin-vec2(mortar))/bevel;\n\t\t\tvec2 c2 = (bmax-uv-vec2(mortar))/bevel;\n\t\t\tvec2 c = min(c1, c2);\n\t\t\tcolor = clamp(min(c.x, c.y), 0.0, 1.0);\n\t\t\treturn vec3(color, mod(bmin, vec2(1.0, 1.0)));\n\t\t}\n\n\t\tvec3 bricks_rb(vec2 uv, vec2 count, float repeat, float offset, float mortar, float bevel) {\n\t\t\tcount *= repeat;\n\t\t\tmortar /= max(count.x, count.y);\n\t\t\tbevel /= max(count.x, count.y);\n\t\t\tfloat x_offset = offset*step(0.5, fract(uv.y*count.y*0.5));\n\t\t\tvec2 bmin = floor(vec2(uv.x*count.x-x_offset, uv.y*count.y));\n\t\t\tbmin.x += x_offset;\n\t\t\tbmin /= count;\n\t\t\treturn brick(uv, bmin, bmin+vec2(1.0)/count, mortar, bevel);\n\t\t}\n\n\t\tvec3 bricks_rb2(vec2 uv, vec2 count, float repeat, float offset, float mortar, float bevel) {\n\t\t\tcount *= repeat;\n\t\t\tmortar /= max(2.0*count.x, count.y);\n\t\t\tbevel /= max(2.0*count.x, count.y);\n\t\t\tfloat x_offset = offset*step(0.5, fract(uv.y*count.y*0.5));\n\t\t\tcount.x = count.x*(1.0+step(0.5, fract(uv.y*count.y*0.5)));\n\t\t\tvec2 bmin = floor(vec2(uv.x*count.x-x_offset, uv.y*count.y));\n\t\t\tbmin.x += x_offset;\n\t\t\tbmin /= count;\n\t\t\treturn brick(uv, bmin, bmin+vec2(1.0)/count, mortar, bevel);\n\t\t}\n\n\t\tvec3 bricks_hb(vec2 uv, vec2 count, float repeat, float offset, float mortar, float bevel) {\n\t\t\tfloat pc = count.x+count.y;\n\t\t\tfloat c = pc*repeat;\n\t\t\tmortar /= c;\n\t\t\tbevel /= c;\n\t\t\tvec2 corner = floor(uv*c);\n\t\t\tfloat cdiff = mod(corner.x-corner.y, pc);\n\t\t\tif (cdiff < count.x) {\n\t\t\t\treturn brick(uv, (corner-vec2(cdiff, 0.0))/c, (corner-vec2(cdiff, 0.0)+vec2(count.x, 1.0))/c, mortar, bevel);\n\t\t\t} else {\n\t\t\t\treturn brick(uv, (corner-vec2(0.0, pc-cdiff-1.0))/c, (corner-vec2(0.0, pc-cdiff-1.0)+vec2(1.0, count.y))/c, mortar, bevel);\n\t\t\t}\n\t\t}\n\n\t\tvec3 bricks_bw(vec2 uv, vec2 count, float repeat, float offset, float mortar, float bevel) {\n\t\t\tvec2 c = 2.0*count*repeat;\n\t\t\tfloat mc = max(c.x, c.y);\n\t\t\tmortar /= mc;\n\t\t\tbevel /= mc;\n\t\t\tvec2 corner1 = floor(uv*c);\n\t\t\tvec2 corner2 = count*floor(repeat*2.0*uv);\n\t\t\tfloat cdiff = mod(dot(floor(repeat*2.0*uv), vec2(1.0)), 2.0);\n\t\t\tvec2 corner;\n\t\t\tvec2 size;\n\t\t\tif (cdiff == 0.0) {\n\t\t\t\tcorner = vec2(corner1.x, corner2.y);\n\t\t\t\tsize = vec2(1.0, count.y);\n\t\t\t} else {\n\t\t\t\tcorner = vec2(corner2.x, corner1.y);\n\t\t\t\tsize = vec2(count.x, 1.0);\n\t\t\t}\n\t\t\treturn brick(uv, corner/c, (corner+size)/c, mortar, bevel);\n\t\t}\n\n\t\tvec3 bricks_sb(vec2 uv, vec2 count, float repeat, float offset, float mortar, float bevel) {\n\t\t\tvec2 c = (count+vec2(1.0))*repeat;\n\t\t\tfloat mc = max(c.x, c.y);\n\t\t\tmortar /= mc;\n\t\t\tbevel /= mc;\n\t\t\tvec2 corner1 = floor(uv*c);\n\t\t\tvec2 corner2 = (count+vec2(1.0))*floor(repeat*uv);\n\t\t\tvec2 rcorner = corner1 - corner2;\n\t\t\tvec2 corner;\n\t\t\tvec2 size;\n\t\t\tif (rcorner.x == 0.0 && rcorner.y < count.y) {\n\t\t\t\tcorner = corner2;\n\t\t\t\tsize = vec2(1.0, count.y);\n\t\t\t} else if (rcorner.y == 0.0) {\n\t\t\t\tcorner = corner2+vec2(1.0, 0.0);\n\t\t\t\tsize = vec2(count.x, 1.0);\n\t\t\t} else if (rcorner.x == count.x) {\n\t\t\t\tcorner = corner2+vec2(count.x, 1.0);\n\t\t\t\tsize = vec2(1.0, count.y);\n\t\t\t} else if (rcorner.y == count.y) {\n\t\t\t\tcorner = corner2+vec2(0.0, count.y);\n\t\t\t\tsize = vec2(count.x, 1.0);\n\t\t\t} else {\n\t\t\t\tcorner = corner2+vec2(1.0);\n\t\t\t\tsize = vec2(count.x-1.0, count.y-1.0);\n\t\t\t}\n\t\t\treturn brick(uv, corner/c, (corner+size)/c, mortar, bevel);\n\t\t}","include":["noise"],"instance":"\n\t\tvec3 $(name)_xyz(vec2 uv) {\n\t\t\treturn bricks_$(pattern)(uv, vec2($(columns), $(rows)), $(repeat), $(row_offset), $(mortar), max(0.001, $(bevel)));\n\t\t}","name":"Bricks","outputs":[{"f":"$(name)_xyz($(uv)).x"},{"rgb":"rand3($(name)_xyz($(uv)).yz+vec2($(seed)))"}],"parameters":[{"default":0,"label":"","name":"pattern","type":"enum","values":[{"name":"Running bond","value":"rb"},{"name":"Running bond (2)","value":"rb2"},{"name":"HerringBone","value":"hb"},{"name":"Basket weave","value":"bw"},{"name":"Spanish bond","value":"sb"}]},{"default":1,"label":"Repeat:","max":8,"min":1,"name":"repeat","step":1,"type":"float","widget":"spinbox"},{"default":6,"label":"Rows:","max":64,"min":1,"name":"rows","step":1,"type":"float","widget":"spinbox"},{"default":3,"label":"Columns:","max":64,"min":1,"name":"columns","step":1,"type":"float","widget":"spinbox"},{"default":0.5,"label":"Offset:","max":1,"min":0,"name":"row_offset","type":"float"},{"default":0.1,"label":"Mortar:","max":0.5,"min":0,"name":"mortar","type":"float"},{"default":0.1,"label":"Bevel:","max":0.5,"min":0,"name":"bevel","type":"float"}]}}