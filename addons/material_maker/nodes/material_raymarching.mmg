{
	"export": {

	},
	"export_paths": {
		"Godot": "D:/Dev/Godot/material-maker-dev/test"
	},
	"name": "material_raymarching",
	"node_position": {
		"x": 0,
		"y": 0
	},
	"parameters": {

	},
	"shader_model": {
		"code": "",
		"exports": {
			"Godot": {
				"export_extension": "tres",
				"files": [
					{
						"file_name": "$(path_prefix).tres",
						"template": "[gd_resource type=\"ShaderMaterial\" load_steps=2 format=2]\n[ext_resource path=\"$(file_prefix).shader\" type=\"Shader\" id=1]\n[resource]\nshader = ExtResource( 1 )\n",
						"type": "template"
					},
					{
						"file_name": "$(path_prefix).shader",
						"template": "shader_type spatial;\n//render_mode unshaded, world_vertex_coords; // to raymarch in world space\nvarying float elapsed_time;\n//---\nvarying vec3 world_camera;\nvarying vec3 world_position;\nconst int MAX_STEPS = 100;\nconst float MAX_DIST = 100.0;\nconst float SURF_DIST = 1e-3;\n$definitions\nvec2 GetDist(vec3 p) {\n$begin_generate\n\tvec2 d = $distance(p);\n$end_generate\n\treturn d;\n}\nvec2 RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO = 0.0;\n\tfloat color = 0.0;\n\tvec2 dS;\n\t\n\tfor (int i = 0; i < MAX_STEPS; i++)\n\t{\n\t\tvec3 p = ro + dO * rd;\n\t\tdS = GetDist(p);\n\t\tdO += dS.x;\n\t\t\n\t\tif (dS.x < SURF_DIST || dO > MAX_DIST) {\n\t\t\tcolor = dS.y;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn vec2(dO, color);\n}\nvec3 GetNormal(vec3 p) {\n\tvec2 e = vec2(1e-2, 0);\n\t\n\tvec3 n = GetDist(p).x - vec3(\n\t\tGetDist(p - e.xyy).x,\n\t\tGetDist(p - e.yxy).x,\n\t\tGetDist(p - e.yyx).x\n\t);\n\t\n\treturn normalize(n);\n}\nvoid vertex() {\n\telapsed_time = TIME;\n\tworld_position = VERTEX;\n\tworld_camera = (inverse(MODELVIEW_MATRIX) * vec4(0, 0, 0, 1)).xyz; //object space\n\t//world_camera = ( CAMERA_MATRIX  * vec4(0, 0, 0, 1)).xyz; //uncomment this to raymarch in world space\n}\nvoid fragment() {\n\tvec3 ro = world_camera;\n\tvec3 rd =  normalize(world_position - ro);\n\t\n\tvec2 rm  = RayMarch(ro, rd);\n\tfloat d = rm.x;\n\tif (d >= MAX_DIST)\n\t\tdiscard;\n\telse\n\t{\n\t\tvec3 p = ro + rd * d;\n$begin_generate\n\t\tALBEDO = $albedo(vec4(p, rm.y));\n\t\tROUGHNESS = $roughness(vec4(p, rm.y)).x;\n\t\tMETALLIC = $metallic(vec4(p, rm.y)).x;\n$end_generate\n\t\tNORMAL = (vec4(GetNormal(p), 1.0)*CAMERA_MATRIX).xyz;\n\t}\n}\n",
						"type": "template"
					}
				]
			}
		},
		"global": "",
		"inputs": [
			{
				"default": "0.0",
				"function": true,
				"label": "Distance",
				"name": "distance",
				"type": "sdf3dc"
			},
			{
				"default": "vec3(1.0)",
				"function": true,
				"label": "Albedo",
				"name": "albedo",
				"type": "tex3d"
			},
			{
				"default": "vec3(0.0)",
				"function": true,
				"label": "Metallic",
				"name": "metallic",
				"type": "tex3d"
			},
			{
				"default": "vec3(1.0)",
				"function": true,
				"label": "Roughness",
				"name": "roughness",
				"type": "tex3d"
			}
		],
		"instance": "",
		"name": "Raymarching Material",
		"outputs": [

		],
		"parameters": [

		],
		"preview_shader": "shader_type spatial;\n//render_mode unshaded, world_vertex_coords; // to raymarch in world space\n\nvarying float elapsed_time;\n\nvarying vec3 world_camera;\nvarying vec3 world_position;\n\nconst int MAX_STEPS = 100;\nconst float MAX_DIST = 100.0;\nconst float SURF_DIST = 1e-3;\n\n$definitions\n\nvec2 GetDist(vec3 p) {\n\n$begin_generate\n\tvec2 d = $distance(p);\n$end_generate\n\n\treturn d;\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO = 0.0;\n\tfloat color = 0.0;\n\tvec2 dS;\n\t\n\tfor (int i = 0; i < MAX_STEPS; i++)\n\t{\n\t\tvec3 p = ro + dO * rd;\n\t\tdS = GetDist(p);\n\t\tdO += dS.x;\n\t\t\n\t\tif (dS.x < SURF_DIST || dO > MAX_DIST) {\n\t\t\tcolor = dS.y;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn vec2(dO, color);\n}\n\nvec3 GetNormal(vec3 p) {\n\tvec2 e = vec2(1e-2, 0);\n\t\n\tvec3 n = GetDist(p).x - vec3(\n\t\tGetDist(p - e.xyy).x,\n\t\tGetDist(p - e.yxy).x,\n\t\tGetDist(p - e.yyx).x\n\t);\n\t\n\treturn normalize(n);\n}\n\nvoid vertex() {\n\telapsed_time = TIME;\n\tworld_position = VERTEX;\n\tworld_camera = (inverse(MODELVIEW_MATRIX) * vec4(0, 0, 0, 1)).xyz; //object space\n\t//world_camera = ( CAMERA_MATRIX  * vec4(0, 0, 0, 1)).xyz; //uncomment this to raymarch in world space\n}\n\nvoid fragment() {\n\tvec3 ro = world_camera;\n\tvec3 rd =  normalize(world_position - ro);\n\t\n\tvec2 rm  = RayMarch(ro, rd);\n\tfloat d = rm.x;\n\n\tif (d >= MAX_DIST)\n\t\tdiscard;\n\telse\n\t{\n\t\tvec3 p = ro + rd * d;\n$begin_generate\n\t\tALBEDO = $albedo(vec4(p, rm.y));\n\t\tROUGHNESS = $roughness(vec4(p, rm.y)).x;\n\t\tMETALLIC = $metallic(vec4(p, rm.y)).x;\n$end_generate\n\t\tNORMAL = (vec4(GetNormal(p), 1.0)*CAMERA_MATRIX).xyz;\n\t}\n}\n"
	},
	"type": "material_export"
}