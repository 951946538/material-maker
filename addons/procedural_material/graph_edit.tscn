[gd_scene load_steps=6 format=2]

[ext_resource path="res://addons/procedural_material/graph_edit.gd" type="Script" id=1]
[ext_resource path="res://addons/procedural_material/nodes/material.tscn" type="PackedScene" id=2]

[sub_resource type="Theme" id=1]


[sub_resource type="Shader" id=2]

code = "shader_type canvas_item;

float rand(vec2 x) {
    return fract(sin(dot(x, vec2(13.9898, 8.141))) * 43758.5453);
}

vec2 rand2(vec2 x) {
    return fract(sin(vec2(dot(x, vec2(13.9898, 8.141)),
						  dot(x, vec2(3.4562, 17.398)))) * 43758.5453);
}

vec3 rand3(vec2 x) {
    return fract(sin(vec3(dot(x, vec2(13.9898, 8.141)),
                          dot(x, vec2(3.4562, 17.398)),
                          dot(x, vec2(13.254, 5.867)))) * 43758.5453);
}

float wave_sin(float x) {
	return 0.5-0.5*cos(3.1415928*2.0*x);
}

float wave_saw(float x) {
	x = fract(x);
	return min(2.0*x, 2.0-2.0*x);
}

float wave_square(float x) {
	return (fract(x) < 0.5) ? 0.0 : 1.0;
}

float mix_multiply(float x, float y) {
	return x*y;
}

float mix_add(float x, float y) {
	return min(x+y, 1.0);
}

float mix_max(float x, float y) {
	return max(x, y);
}

float mix_min(float x, float y) {
	return min(x, y);
}

float mix_min(float x, float y) {
	return min(x, y);
}

float mix_xor(float x, float y) {
	return min(x+y, 2.0-x-y);
}

float mix_pow(float x, float y) {
	return pow(x, y);
}

vec3 blend_normal(vec2 uv, vec3 c1, vec3 c2, float opacity) {
	return opacity*c1 + (1.0-opacity)*c2;
}

vec3 blend_dissolve(vec2 uv, vec3 c1, vec3 c2, float opacity) {
	if (rand(uv) < opacity) {
		return c1;
	} else {
		return c2;
	}
}

vec3 blend_multiply(vec2 uv, vec3 c1, vec3 c2, float opacity) {
	return opacity*c1*c2 + (1.0-opacity)*c2;
}

vec3 blend_screen(vec2 uv, vec3 c1, vec3 c2, float opacity) {
	return opacity*(1.0-(1.0-c1)*(1.0-c2)) + (1.0-opacity)*c2;
}

float blend_overlay_f(float c1, float c2) {
	return (c1 < 0.5) ? (2.0*c1*c2) : (1.0-2.0*(1.0-c1)*(1.0-c2));
}

vec3 blend_overlay(vec2 uv, vec3 c1, vec3 c2, float opacity) {
	return opacity*vec3(blend_overlay_f(c1.x, c2.x), blend_overlay_f(c1.y, c2.y), blend_overlay_f(c1.z, c2.z)) + (1.0-opacity)*c2;
}

vec3 blend_hard_light(vec2 uv, vec3 c1, vec3 c2, float opacity) {
	return opacity*0.5*(c1*c2+blend_overlay(uv, c1, c2, 1.0)) + (1.0-opacity)*c2;
}

float blend_soft_light_f(float c1, float c2) {
	return (c2 < 0.5) ? (2.0*c1*c2+c1*c1*(1.0-2.0*c2)) : 2.0*c1*(1.0-c2)+sqrt(c1)*(2.0*c2-1.0);
}

vec3 blend_soft_light(vec2 uv, vec3 c1, vec3 c2, float opacity) {
	return opacity*vec3(blend_soft_light_f(c1.x, c2.x), blend_soft_light_f(c1.y, c2.y), blend_soft_light_f(c1.z, c2.z)) + (1.0-opacity)*c2;
}

float blend_burn_f(float c1, float c2) {
	return (c1==0.0)?c1:max((1.0-((1.0-c2)/c1)),0.0);
}

vec3 blend_burn(vec2 uv, vec3 c1, vec3 c2, float opacity) {
	return opacity*vec3(blend_burn_f(c1.x, c2.x), blend_burn_f(c1.y, c2.y), blend_burn_f(c1.z, c2.z)) + (1.0-opacity)*c2;
}

float blend_dodge_f(float c1, float c2) {
	return (c1==1.0)?c1:min(c2/(1.0-c1),1.0);
}

vec3 blend_dodge(vec2 uv, vec3 c1, vec3 c2, float opacity) {
	return opacity*vec3(blend_dodge_f(c1.x, c2.x), blend_dodge_f(c1.y, c2.y), blend_dodge_f(c1.z, c2.z)) + (1.0-opacity)*c2;
}

vec3 blend_lighten(vec2 uv, vec3 c1, vec3 c2, float opacity) {
	return opacity*max(c1, c2) + (1.0-opacity)*c2;
}

vec3 blend_darken(vec2 uv, vec3 c1, vec3 c2, float opacity) {
	return opacity*min(c1, c2) + (1.0-opacity)*c2;
}

vec2 transform(vec2 uv, vec2 translate, float rotate, float scale) {
	vec2 rv;
	uv -= vec2(0.5);
	rv.x = cos(rotate)*uv.x + sin(rotate)*uv.y;
	rv.y = -sin(rotate)*uv.x + cos(rotate)*uv.y;
	rv /= scale;
	rv += vec2(0.5);
	rv -= translate;
	return rv;
}

float bricks(vec2 uv, vec2 count, float offset, float mortar, float bevel) {
	mortar /= max(count.x, count.y);
	bevel /= max(count.x, count.y);
	float fract_x = fract(uv.x*count.x+offset*step(0.5, fract(uv.y*count.y*0.5)));
	float slope_x = 1.0/(bevel*count.x);
	float off = 0.5*mortar/bevel;
	float f1 = fract_x*slope_x-off;
	float f2 = (1.0-fract_x)*slope_x-off;
	float fract_y = fract(uv.y*count.y);
	float slope_y = 1.0/(bevel*count.y);
	float f3 = fract_y*slope_y-off;
	float f4 = (1.0-fract_y)*slope_y-off;
	return max(0.0, min(1.0, min(min(f1, f2), min(f3, f4))));
}

float colored_bricks(vec2 uv, vec2 count, float offset) {
	float x = floor(uv.x*count.x+offset*step(0.5, fract(uv.y*count.y*0.5)));
	float y = floor(uv.y*count.y);
	return fract(x/3.0+y/7.0);
}

float perlin(vec2 uv, vec2 size, int iterations, float persistence, int seed) {
	uv += vec2(float(seed)*0.1234567);
    float rv = 0.0;
    float coef = 1.0;
    float acc = 0.0;
    for (int i = 0; i < iterations; ++i) {
    	vec2 step = vec2(1.0)/size;
        float f0 = rand(floor(fract(uv)*size));
        float f1 = rand(floor(fract(uv+vec2(step.x, 0.0))*size));
        float f2 = rand(floor(fract(uv+vec2(0.0, step.y))*size));
        float f3 = rand(floor(fract(uv+vec2(step.x, step.y))*size));
        vec2 mixval = fract(uv*size);
        mixval = 0.5*(1.0-cos(3.1415928*mixval));
        rv += coef * mix(mix(f0, f1, mixval.x), mix(f2, f3, mixval.x), mixval.y);
        acc += coef;
        size *= 2.0;
        coef *= persistence;
    }
    
    return rv / acc;
}

vec4 voronoi(vec2 uv, vec2 size, float intensity, int seed) {
	uv += vec2(float(seed)*0.1234567);
    uv *= size;
    float best_distance0 = 1.0;
    float best_distance1 = 1.0;
    vec2 point0;
    vec2 point1;
    vec2 p0 = floor(uv);
    for (int dx = -1; dx < 2; ++dx) {
    	for (int dy = -1; dy < 2; ++dy) {
            vec2 d = vec2(float(dx), float(dy));
            vec2 p = p0+d;
            p += rand2(mod(p, size));
            float distance = length((uv - p) / size);
            if (best_distance0 > distance) {
            	best_distance1 = best_distance0;
            	best_distance0 = distance;
                point1 = point0;
                point0 = p;
            } else if (best_distance1 > distance) {
            	best_distance1 = distance;
                point1 = p;
            }
        }
    }
    float edge_distance = dot(uv - 0.5*(point0+point1), normalize(point0-point1));
    
    return vec4(point0, best_distance0*length(size)*intensity, edge_distance);
}

float Perlin_f(vec2 uv) { return perlin(uv, vec2(4.000000, 4.000000), 6, 0.500000000, 2375); }
float Bricks_f(vec2 uv) { return bricks(uv, vec2(3, 6), 0.5, 0.05, 0.2); }
vec3 colorize_3_gradient(float x) {
  if (x < 0.000000000) {
    return vec3(0.273438007,0.273438007,0.273438007);
  } else if (x < 1.000000000) {
    return vec3(0.273438007,0.273438007,0.273438007)+x*vec3(-0.273438007,-0.273438007,-0.273438007);
  }
  return vec3(0.000000000,0.000000000,0.000000000);
}
void fragment() {
float Perlin_0_f = Perlin_f(UV+vec2(0.01, 0.0));
float Perlin_1_f = Perlin_f(UV-vec2(0.01, 0.0));
float Perlin_2_f = Perlin_f(UV+vec2(0.0, 0.01));
float Perlin_3_f = Perlin_f(UV-vec2(0.0, 0.01));
vec2 Warp_0_uv = UV+0.100000001*vec2((Perlin_0_f)-(Perlin_1_f), (Perlin_2_f)-(Perlin_3_f));
float Bricks_0_f = Bricks_f(Warp_0_uv);
vec3 Warp_0_rgb = vec3(Bricks_0_f);
float Warp_0_f = dot(vec3(Bricks_0_f), vec3(1.0))/3.0;
vec3 colorize_3_0_rgb = colorize_3_gradient(Warp_0_f);
COLOR = vec4(colorize_3_0_rgb, 1.0);
}
"

[sub_resource type="ShaderMaterial" id=3]

render_priority = 0
shader = SubResource( 2 )

[node name="GraphEdit" type="GraphEdit" index="0"]

self_modulate = Color( 1, 1, 1, 0 )
anchor_left = 0.0
anchor_top = 0.0
anchor_right = 1.0
anchor_bottom = 1.0
rect_pivot_offset = Vector2( 0, 0 )
rect_clip_content = true
focus_mode = 2
mouse_filter = 0
mouse_default_cursor_shape = 0
size_flags_horizontal = 1
size_flags_vertical = 1
right_disconnects = true
scroll_offset = Vector2( 0, 0 )
snap_distance = 20
use_snap = false
zoom = 1.0
script = ExtResource( 1 )
_sections_unfolded = [ "Material", "Mouse", "Visibility" ]

[node name="Material" parent="." index="0" instance=ExtResource( 2 )]

theme = SubResource( 1 )
_sections_unfolded = [ "Anchor", "Margin", "Mouse", "Theme", "slot", "slot/2", "slot/3", "slot/4", "slot/5" ]

[node name="Timer" type="Timer" parent="." index="1"]

process_mode = 1
wait_time = 0.2
one_shot = true
autostart = false

[node name="SaveViewport" type="Viewport" parent="." index="2"]

arvr = false
size = Vector2( 0, 0 )
own_world = true
world = null
transparent_bg = false
msaa = 2
hdr = false
disable_3d = false
usage = 2
debug_draw = 0
render_target_v_flip = true
render_target_clear_mode = 0
render_target_update_mode = 1
audio_listener_enable_2d = false
audio_listener_enable_3d = false
physics_object_picking = false
gui_disable_input = true
gui_snap_controls_to_pixels = true
shadow_atlas_size = 0
shadow_atlas_quad_0 = 2
shadow_atlas_quad_1 = 2
shadow_atlas_quad_2 = 3
shadow_atlas_quad_3 = 4
_sections_unfolded = [ "GUI", "Render Target", "Rendering" ]

[node name="ColorRect" type="ColorRect" parent="SaveViewport" index="0"]

material = SubResource( 3 )
anchor_left = 0.0
anchor_top = 0.0
anchor_right = 0.0
anchor_bottom = 0.0
margin_right = 40.0
margin_bottom = 40.0
rect_pivot_offset = Vector2( 0, 0 )
rect_clip_content = false
mouse_filter = 0
mouse_default_cursor_shape = 0
size_flags_horizontal = 1
size_flags_vertical = 1
color = Color( 1, 1, 1, 1 )
_sections_unfolded = [ "Material", "Rect" ]

[node name="Timer" type="Timer" parent="SaveViewport" index="1"]

process_mode = 1
wait_time = 0.1
one_shot = true
autostart = false

[connection signal="connection_request" from="." to="." method="connect_node"]

[connection signal="disconnection_request" from="." to="." method="disconnect_node"]

[connection signal="timeout" from="Timer" to="." method="do_send_changed_signal"]


